var searchIndex = {};
searchIndex['permutohedron'] = {"items":[[0,"","permutohedron","",null,null],[3,"Heap","","Heap's algorithm for generating permutations.",null,null],[5,"heap_recursive","","Heap's algorithm for generating permutations, recursive version.",null,null],[5,"factorial","","Compute *n!* (*n* factorial)",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[17,"MAXHEAP","","Maximum number of elements we can generate permutations for using\nHeap's algorithm (iterative version).",null,null],[8,"LexicalPermutation","","Permute a slice into its next or previous permutation (in lexical order).",null,null],[10,"next_permutation","","Return `true` if the slice was permuted, `false` if it is already\nat the last ordered permutation.",0,{"inputs":[{"name":"lexicalpermutation"}],"output":{"name":"bool"}}],[10,"prev_permutation","","Return `true` if the slice was permuted, `false` if it is already\nat the first ordered permutation.",0,{"inputs":[{"name":"lexicalpermutation"}],"output":{"name":"bool"}}],[11,"new","","Create a new `Heap`.",1,{"inputs":[{"name":"heap"},{"name":"data"}],"output":{"name":"self"}}],[11,"get","","Return a reference to the inner data",1,{"inputs":[{"name":"heap"}],"output":{"name":"data"}}],[11,"get_mut","","Return a mutable reference to the inner data",1,{"inputs":[{"name":"heap"}],"output":{"name":"data"}}],[11,"reset","","Reset the permutations walker, without changing the data. It allows\ngenerating permutations again with the current state as starting\npoint.",1,{"inputs":[{"name":"heap"}],"output":null}],[11,"next_permutation","","Step the internal data into the next permutation and return\na reference to it. Return `None` when all permutations\nhave been visited.",1,{"inputs":[{"name":"heap"}],"output":{"name":"option"}}],[11,"next","","",1,{"inputs":[{"name":"heap"}],"output":{"name":"option"}}]],"paths":[[8,"LexicalPermutation"],[3,"Heap"]]};
initSearch(searchIndex);
