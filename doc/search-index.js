var searchIndex = {};
searchIndex['permutohedron'] = {"items":[[0,"","permutohedron","",null,null],[3,"Heap","","Heap's algorithm for generating permutations.",null,null],[5,"heap_recursive","","Heap's algorithm for generating permutations, recursive version.",null,null],[5,"factorial","","Compute *n!* (*n* factorial)",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[17,"MAXHEAP","","Maximum number of elements we can generate permutations for using\nHeap's algorithm (iterative version).",null,null],[11,"new","","Create a new `Heap`.",0,{"inputs":[{"name":"heap"},{"name":"data"}],"output":{"name":"self"}}],[11,"get","","Return a reference to the inner data",0,{"inputs":[{"name":"heap"}],"output":{"name":"data"}}],[11,"get_mut","","Return a mutable reference to the inner data",0,{"inputs":[{"name":"heap"}],"output":{"name":"data"}}],[11,"reset","","Reset the permutations walker, without changing the data. It allows\ngenerating permutations again with the current state as starting\npoint.",0,{"inputs":[{"name":"heap"}],"output":null}],[11,"next_permutation","","Step the internal data into the next permutation and return\na reference to it. Return `None` when all permutations\nhave been visited.",0,{"inputs":[{"name":"heap"}],"output":{"name":"option"}}],[11,"next","","",0,{"inputs":[{"name":"heap"}],"output":{"name":"option"}}]],"paths":[[3,"Heap"]]};
initSearch(searchIndex);
